---
title: "ADNI_RNA_analysis"
author: "Christelle Schneuwly Diaz"
date: "2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Differential expression analysis 

The analysis focuses on identifying differentially expressed genes (DEGs) across various diagnostic groups: cognitively normal (CN), mild cognitive impairment (MCI), and Alzheimer's disease (AD). The workflow encompasses data preprocessing, normalization, statistical modeling, and visualization, primarily utilizing the limma package, which is well-suited for analyzing microarray data.

```{r Import packages and data}
library(ADNIMERGE)

library(MGMM)

library(edgeR)
library(locfit)
library(limma)
library(DESeq2)
library(mixtools)

library(dplyr)
library(tidyverse)
library(RColorBrewer)
library(pheatmap)
library(broom)
library(rootSolve)
library(Hmisc)

library(ggplot2)
library(ggrepel)
library(reshape2)
library(ggfortify)

library(samr)


filtered_gene_data <- read.csv("../data/microarray/filtered_gene_counts.csv", 
                               row.names = 1, 
                               check.names = FALSE,
                               stringsAsFactors = FALSE)
filtered_gene_info <- read.csv("../data/microarray/filtered_genes.csv", 
                                row.names = 1, 
                               check.names = FALSE,
                                stringsAsFactors = FALSE)
filtered_samples <- read.csv("../data/microarray/filtered_samples.csv", 
                              row.names = 1, 
                             check.names = FALSE,
                              stringsAsFactors = FALSE)

# CHECK WITHOUT FILTERING LOW EXPRESSION GENES 

# Remove problematic samples
exclude_ids <- c("128_S_2002", "003_S_2374", "116_S_4167", "033_S_4176", 
                 "033_S_4179", "098_S_4215", "941_S_4292", "073_S_4300", 
                 "018_S_4349", "116_S_4453", "135_S_4489", "033_S_4505")

gene_counts <- filtered_gene_data[, !colnames(filtered_gene_data) %in% exclude_ids]
sample_meta <- filtered_samples[!filtered_samples$SubjectID %in% exclude_ids, ]
gene_info <- filtered_gene_info
rownames(gene_info) <- gene_info$Symbol
```

The limma package is employed for differential expression analysis, which is appropriate for microarray data. Diagnostic groups are encoded as factors, and a design matrix is constructed without an intercept in order to model each group explicitly. Pairwise contrasts are then defined to compare AD vs. CN, MCI vs. CN, and AD vs. MCI. The linear model is fitted using lmFit, contrasts are applied with contrasts.fit, and empirical Bayes moderation is performed using eBayes. Finally, the topTable function is used to extract the results for each contrast, with p-values adjusted using the false discovery rate (FDR) method.

```{r limma}
# Step 1: Prepare expression matrix and metadata
expr_matrix <- gene_counts
meta <- sample_meta

meta$group <- factor(make.names(meta$DX))  # CN, MCI, AD

design <- model.matrix(~ 0 + group, data = meta)
colnames(design) <- levels(meta$group)  # CN, MCI, AD

fit <- lmFit(expr_matrix, design)

# Define pairwise contrasts
contrast_matrix <- makeContrasts(
  ADvsCN = AD - CN,
  MCIvsCN = MCI - CN,
  ADvsMCI = AD - MCI,
  levels = design
)

fit2 <- contrasts.fit(fit, contrast_matrix)
fit2 <- eBayes(fit2)

# You can do this for each contrast:
results_ADvsCN <- topTable(fit2, coef = "ADvsCN", adjust = "fdr", number = Inf)
results_MCIvsCN <- topTable(fit2, coef = "MCIvsCN", adjust = "fdr", number = Inf)
results_ADvsMCI <- topTable(fit2, coef = "ADvsMCI", adjust = "fdr", number = Inf)

plot_volcano <- function(top_table, 
                         contrast_name = "", 
                         dge_threshold = 0.05, 
                         logfc_cutoff = 1,
                         x_limits = c(-3, 3)) {
  
  # Add color group column based on thresholds
  top_table$color_group <- ifelse(
    top_table$adj.P.Val < dge_threshold & top_table$logFC > logfc_cutoff, "Upregulated",
    ifelse(top_table$adj.P.Val < dge_threshold & top_table$logFC < -logfc_cutoff, "Downregulated", "Not significant")
  )
  
  # Identify genes to label
  highlight_genes <- rownames(top_table)[
    top_table$adj.P.Val < dge_threshold & abs(top_table$logFC) > logfc_cutoff
  ]

  # Create a filtered dataframe for labeling
  highlight_data <- top_table[rownames(top_table) %in% highlight_genes, ]
  
  # Plot
  ggplot(top_table, aes(x = logFC, y = -log10(adj.P.Val))) +
    geom_point(aes(color = color_group), alpha = 0.5, size = 2.5) +  # Transparent points
    geom_hline(yintercept = -log10(dge_threshold), linetype = "dashed", color = "darkgrey", linewidth = 1) +
    geom_vline(xintercept = c(-logfc_cutoff, logfc_cutoff), linetype = "dotted", color = "darkgrey") +
    scale_color_manual(values = c("Upregulated" = "red", "Downregulated" = "blue", "Not significant" = "lightgrey")) +
    xlim(x_limits) +  # Set x-axis boundaries
    labs(
      x = "Log2 Fold Change", 
      y = "-Log10 Adjusted P-Value",
      title = paste("Volcano Plot:", contrast_name)
    ) +
    theme_minimal(base_size = 14) +
    theme(
      legend.position = "none",
      panel.grid = element_blank(),     # Remove background grid
      plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
      axis.text = element_text(size = 12),
      axis.title = element_text(size = 14)
    ) +
    geom_text_repel(
      data = highlight_data,
      aes(label = rownames(highlight_data)),
      size = 4,
      box.padding = 0.4,
      point.padding = 0.2,
      segment.color = 'grey50',
      max.overlaps = 10
    )
}


# Example:
plot_volcano(results_ADvsCN, "AD vs CN", logfc_cutoff = 0.0, dge_threshold = 0.05, x_limits = c(-0.5, 0.5))
# Example:
plot_volcano(results_ADvsMCI, "AD vs MCI", logfc_cutoff = 0.0, dge_threshold = 0.05, x_limits = c(-0.5, 0.5))
# Example:
plot_volcano(results_MCIvsCN, "MCI vs CN", logfc_cutoff = 0.0, dge_threshold = 0.05, x_limits = c(-0.5, 0.5))
```

```{r Extract differentially expressed genes}
# Replace these with your actual results objects
# Filter for adjusted P-value < 0.05
# Filter significant genes based on adj.P.Val and logFC cutoff
logfc_cutoff <- 0.0
dge_threshold <- 0.05

cn_ad <- results_ADvsCN[
  results_ADvsCN$adj.P.Val < dge_threshold & abs(results_ADvsCN$logFC) > logfc_cutoff, 
]

cn_mci <- results_MCIvsCN[
  results_MCIvsCN$adj.P.Val < dge_threshold & abs(results_MCIvsCN$logFC) > logfc_cutoff, 
]

mci_ad<- results_ADvsMCI[
  results_ADvsMCI$adj.P.Val < dge_threshold & abs(results_ADvsMCI$logFC) > logfc_cutoff, 
]

# Add contrast labels
cn_ad$Test <- "CN_AD"
mci_ad$Test <- "MCI_AD"
# cn_mci$Test <- "CN_MCI"

# Add gene symbol column (assuming rownames are gene symbols)
cn_ad$Symbol <- rownames(cn_ad)
mci_ad$Symbol <- rownames(mci_ad)
# cn_mci$Symbol <- rownames(cn_mci)

# Combine all results
df_dge <- rbind(cn_ad, cn_mci, mci_ad)

# Optional: convert all columns to character (depends on your need)
df_dge <- data.frame(lapply(df_dge, as.character), stringsAsFactors = FALSE)

# Save to CSV
write.csv(df_dge, "../data/microarray/dge_results_limma_filtered.csv", row.names = FALSE)
```

```{r Sequential limma and heatmaps}

# Create DGEList from counts and sample metadata
dge <- DGEList(counts = gene_counts)
dge$samples$group <- sample_meta$DX  # ensure group info is available

plot_heatmap <- function(gene_list, title, dge_obj) {
  # Get expression matrix (logCPM)
  expr_matrix <- cpm(dge_obj, log = TRUE)[gene_list, ]

  # Z-score normalization (row-wise)
  z_expr <- t(scale(t(expr_matrix)))

  # Sample group annotations
  annotation_col <- data.frame(
    Diagnosis = dge_obj$samples$group
  )
  rownames(annotation_col) <- colnames(z_expr)

  # Plot heatmap
  pheatmap(
    z_expr,
    annotation_col = annotation_col,
    show_rownames = TRUE,
    show_colnames = FALSE,
    color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
    cluster_cols = TRUE,
    cluster_rows = TRUE,
    fontsize_row = 7,
    main = title
  )
}

top_cn_ad <- cn_ad
top_cn_mci <- cn_mci
top_mci_ad <- mci_ad

top_genes_cn_ad <- rownames(top_cn_ad[
  top_cn_ad$adj.P.Val < dge_threshold & abs(top_cn_ad$logFC) > logfc_cutoff
  , ])

top_genes_cn_mci <- rownames(top_cn_mci[
  top_cn_mci$adj.P.Val < dge_threshold & abs(top_cn_mci$logFC) > logfc_cutoff, ])

top_genes_mci_ad <- rownames(top_mci_ad[
  top_mci_ad$adj.P.Val < dge_threshold & abs(top_mci_ad$logFC) > logfc_cutoff, ])

plot_heatmap(top_genes_cn_ad, "Top DE Genes: CN vs AD", dge)
#plot_heatmap(top_genes_cn_mci, "Top DE Genes: CN vs MCI", dge)
plot_heatmap(top_genes_mci_ad, "Top DE Genes: MCI vs AD", dge)
```